<!doctype html>
<html>
<head>
    <title>Blog</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <link rel="apple-touch-icon" sizes="57x57"
                                 href="/static/favicon/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60"
                                 href="/static/favicon/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72"
                                 href="/static/favicon/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76"
                                 href="/static/favicon/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114"
                                 href="/static/favicon/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120"
                                 href="/static/favicon/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144"
                                 href="/static/favicon/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152"
                                 href="/static/favicon/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180"
                                 href="/static/favicon/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/static/favicon/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/static/favicon/android-chrome-192x192.png"
                                      sizes="192x192">
    <link rel="icon" type="image/png" href="/static/favicon/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/static/favicon/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/static/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="msapplication-TileImage" content="/static/favicon/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">

    <link rel="stylesheet" type="text/css"
  href="//cloud.typography.com/7821852/748866/css/fonts.css" />

    <link rel="stylesheet" href="/static/css/app.css" />

</head>


<body>
    <main>
    <nav>
    <a href="/" class="site-logo"><img class="icon" src="http://npbee.me/static/images/me_alt.jpeg" /></a>
    <div class="social">
        <a href="http://twitter.com/npbeep" class="main-nav__break-right"><img
            class="icon" src="/static/images/icons/icomoon/twitter.svg" /></a>
        <a href="mailto:nick@npbee.me" class=""><img class="icon" src="/static/images/icons/icomoon/mail.svg" /></a>
        <a href="http://github.com/npbee" class="github-link"><img class="icon" src="/static/images/icons/github/mark.svg" /></a>
    </div>
</nav>


        <section class="post">
            <header class="post-summary">
                <h1 class="header">Higher-Order, Higher-Order React Components</h1>
                <small>March, 06 2016</small>
                <em>An experiment in composing React components</em>
            </header>
            <article><h2 id="a-quick-intro">A Quick Intro</h2>
<p>If you’ve kept up at all with the ever-evolving React best-practices, you’ve probably come across the concept of <a href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775">higher-order components</a>.  But just to put it in my own words, here’s a quick recap:</p>
<pre><code class="lang-javascript"><span class="comment">// enhancer.js</span>

<span class="comment">// Accepts a component and returns a new component that has </span>
<span class="comment">// some additional properties attached</span>
export <span class="keyword">default</span> function enhance(<span class="type">ComposedComponent</span>) {
    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
        render() {
            <span class="keyword">return</span> &lt;<span class="type">ComposedComponent</span> {…<span class="keyword">this</span>.props} text=‘<span class="type">Enhanced</span>!’ /&gt;;
        }
    }
}


<span class="comment">// component.js</span>
<span class="keyword">import</span> <span class="type">Enhance</span> from ‘./enhancer’;

<span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{  
    render() {

        <span class="comment">// The `text` prop is available via the enhancer</span>
        const { text } = <span class="keyword">this</span>.props;

        <span class="comment">// &lt;div&gt;Enhanced!&lt;/div&gt;</span>
        <span class="keyword">return</span> &lt;div&gt;{text}&lt;/div&gt;;
    }        
}

export <span class="keyword">default</span> <span class="type">Enhance</span>(<span class="type">MyComponent</span>);
</code></pre>
<p>The general idea is that you have this function that accepts a component as an argument and returns a <em>new</em> component with some additional <code>props</code> attached. Here’s a good reference:  <a href="https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.q5if6eyah">https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.q5if6eyah</a>.</p>
<p>Why would you want to use this pattern?  In short, it’s just a more functional way of extending a component with new functionality or data.  You could achieve something similar in a more object-oriented way with inheritance and prototypes.  I won’t go into functional versus object-oriented programming, but suffice it to say that I prefer the functional approach so that’s what I choose to use in most situations.  </p>
<p>In this article I’m going to go into are some trials and tribulations that I’ve had using this pattern on a large React app.</p>
<h2 id="level-one-basic-enhancement">Level One: Basic Enhancement</h2>
<p>A simple higher-order component looks like the sample code above.  Here’s a pen:</p>
<p><p data-height="268" data-theme-id="0" data-slug-hash="dMGPZL" data-default-tab="result" data-user="npbee" class="codepen">See the Pen <a href="http://codepen.io/npbee/pen/dMGPZL/">Level One</a> by Nick Ball (<a href="http://codepen.io/npbee">@npbee</a>) on <a href="http://codepen.io">CodePen</a>.</p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>Once you get used the pattern, this example is pretty straightforward.  Now let’s step it up a level by doing some composition.</p>
<h2 id="level-two-higher-order-composition">Level Two: Higher-Order Composition</h2>
<p>As my app grew, I began to need the functionality from multiple higher-order components.  I like to keep my higher-order components quite focused to a specific domain or task, so the logical step was to <em>compose</em> multiple higher-order components together like so:</p>
<pre><code class="lang-javascript"><span class="comment">// textEnhancer.js</span>
export <span class="keyword">default</span> function textEnhancer(<span class="type">ComposedComponent</span>) {
    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
        render() {
            <span class="keyword">return</span> &lt;<span class="type">ComposedComponent</span> {…<span class="keyword">this</span>.props} text=‘<span class="type">Enhanced</span>!’ /&gt;;
        }
    }
}

<span class="comment">// numberEnhancer.js</span>
export <span class="keyword">default</span> function numberEnhancer(<span class="type">ComposedComponent</span>) {
    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
        render() {
            <span class="keyword">return</span> &lt;<span class="type">ComposedComponent</span> {…<span class="keyword">this</span>.props} number={<span class="number">100</span>} /&gt;;
        }
    }
}

<span class="comment">// component.js</span>
<span class="keyword">import</span> textEnhancer from ‘./textEnhancer’;
<span class="keyword">import</span> numberEnhancer from ‘./numberEnhancer’;

<span class="comment">// I’m a nerd and I like to refer to lodash’s “flowRight” as “compose”</span>
<span class="keyword">import</span> compose from ‘lodash/flowRight’;

<span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{  
    render() {

        <span class="comment">// Both the `text` and `number` props are available via the enhancers</span>
        const { text, number } = <span class="keyword">this</span>.props;

        <span class="comment">// &lt;div&gt;Enhanced!100&lt;/div&gt;</span>
        <span class="keyword">return</span> &lt;div&gt;{text}{number}&lt;/div&gt;;
    }        
}

export <span class="keyword">default</span> compose(
    textEnhancer, 
    numberEnhancer
)(<span class="type">MyComponent</span>);
</code></pre>
<p>This pattern allows for multiple higher-order components to be composed together to provide new functionality to a single component.  I like it because it allows the higher-order components to stay focused and small and also allows for the final child component to stay presentational (just renders data).</p>
<p>Here’s a more practical pen example:</p>
<p><p data-height="268" data-theme-id="0" data-slug-hash="dMGPZL" data-default-tab="result" data-user="npbee" class="codepen">See the Pen <a href="http://codepen.io/npbee/pen/dMGPZL/">Level One</a> by Nick Ball (<a href="http://codepen.io/npbee">@npbee</a>) on <a href="http://codepen.io">CodePen</a>.</p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<h2 id="complication-1-order-matters">Complication #1: Order Matters</h2>
<p>One thing that wasn’t entirely obvious to me using this pattern is that <em>order matters</em>.  Meaning, the order that you define your composition chain in makes a difference in what props are available at what time.  </p>
<p>Here’s an example of something that <em>would not</em> work:</p>
<pre><code class="lang-javascript"><span class="comment">// textEnhancer.js</span>
export <span class="keyword">default</span> function textEnhancer(<span class="type">ComposedComponent</span>) {
    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
        render() {

            <span class="comment">// FAIL:  The number prop isn’t available here</span>
            const { number } = <span class="keyword">this</span>.props;
            const text = `<span class="type">Enhanced</span>! ${number}`;

            <span class="keyword">return</span> &lt;<span class="type">ComposedComponent</span> {…<span class="keyword">this</span>.props} text={text} /&gt;;
        }
    }
}

<span class="comment">// numberEnhancer.js</span>
export <span class="keyword">default</span> function numberEnhancer(<span class="type">ComposedComponent</span>) {
    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
        render() {
            <span class="keyword">return</span> &lt;<span class="type">ComposedComponent</span> {…<span class="keyword">this</span>.props} number={<span class="number">100</span>} /&gt;;
        }
    }
}

<span class="comment">// component.js</span>
<span class="keyword">import</span> textEnhancer from ‘./textEnhancer’;
<span class="keyword">import</span> numberEnhancer from ‘./numberEnhancer’;

<span class="comment">// I’m a nerd and I like to refer to lodash’s “flowRight” as “compose”</span>
<span class="keyword">import</span> compose from ‘lodash/flowRight’;

<span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{  
    render() {

        <span class="comment">// Both the `text` and `number` props are available via the enhancers</span>
        const { text, number } = <span class="keyword">this</span>.props;

        <span class="comment">// &lt;div&gt;Enhanced!100&lt;/div&gt;</span>
        <span class="keyword">return</span> &lt;div&gt;{text}{number}&lt;/div&gt;;
    }        
}

export <span class="keyword">default</span> compose(
    textEnhancer, 
    numberEnhancer
)(<span class="type">MyComponent</span>);
</code></pre>
<p>Notice that in the <code>textEnhancer</code> component we’re trying to access <code>this.props.number</code> but that prop hasn’t been defined yet.  It’s easier to see here but harder to see when the components are more complex.</p>
<p>The thing to remember is that a React app is a <em>tree</em> of components and data is passed down from parent to child.  The <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en">React Dev Tools</a> are a great way to visualize this idea.  In the above example, the tree would look something like:</p>
<pre><code class="lang-javascript"><span class="section">&lt;TextEnhancer /&gt;</span>
    <span class="section">&lt;NumberEnhancer /&gt;</span>
        <span class="section">&lt;MyComponent /&gt;</span>
</code></pre>
<p>It’s easier to see here that the <code>TextEnhancer</code> component wouldn’t have access to anything provided by the <code>NumberEnhancer</code> because it’s the parent component.</p>
<p>It also might take a second glance to realize how the component tree is rendered based on how we defined our composition chain:</p>
<pre><code class="lang-javascript"><span class="title">export</span> <span class="keyword">default</span> compose(
    <span class="title">textEnhancer</span>, 
    <span class="title">numberEnhancer</span>
)(<span class="type">MyComponent</span>);
</code></pre>
<p>A <code>compose</code> function runs from right-to-left so <code>numberEnhancer</code> is run first and <code>textEnhancer</code> second, but our composition tree ends up with <code>TextEnhancer</code> as the parent.  It’s easier to see by writing out all of the function compositions manually:</p>
<pre><code class="lang-javascript"><span class="title">export</span> <span class="keyword">default</span> textEnhancer(<span class="title">numberEnhancer</span>(<span class="type">MyComponent</span>))
</code></pre>
<p>Given that <code>textEnhancer</code> is the <em>last</em> function to run, it will be the parent component.</p>
<p>This complication is something that needs to be kept in mind, but ultimately can&#39;t really be helped.  In fact, running into this problem generally means that you need to refactor your component tree a bit.  If two components depend on the same prop, then that prop should be abstracted into a common parent component.</p>
<h2 id="complication-2-prop-name-clashes">Complication #2: Prop Name Clashes</h2>
<p>Another problem that I didn’t actually run into until quite some time had past was prop name clashes.  </p>
<p>Take this example:</p>
<pre><code class="lang-javascript"><span class="comment">// textEnhancer.js</span>
export <span class="keyword">default</span> function textEnhancer(<span class="type">ComposedComponent</span>) {
    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
        render() {
            <span class="keyword">return</span> &lt;<span class="type">ComposedComponent</span> {…<span class="keyword">this</span>.props} text=‘<span class="type">Enhanced</span>!’ /&gt;;
        }
    }
}

<span class="comment">// wordEnhancer.js</span>
export <span class="keyword">default</span> function wordEnhancer(<span class="type">ComposedComponent</span>) {
    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedWordComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
        render() {
            <span class="keyword">return</span> &lt;<span class="type">ComposedComponent</span> {…<span class="keyword">this</span>.props} text=`<span class="type">Whoops</span>.` /&gt;;
        }
    }
}

<span class="comment">// component.js</span>
<span class="keyword">import</span> textEnhancer from ‘./textEnhancer’;
<span class="keyword">import</span> wordEnhancer from ‘./wordEnhancer’;
<span class="keyword">import</span> compose from ‘lodash/flowRight’;

<span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{  
    render() {
        const { text } = <span class="keyword">this</span>.props;

        <span class="comment">// &lt;div&gt;Whoops.&lt;/div&gt;</span>
        <span class="keyword">return</span> &lt;div&gt;{text}&lt;/div&gt;;
    }        
}

export <span class="keyword">default</span> compose(
    textEnhancer, 
    wordEnhancer
)(<span class="type">MyComponent</span>);
</code></pre>
<p>Here you can see that both <code>textEnhancer</code> and <code>wordEnhancer</code> are using the same prop name of <code>text</code>.  Because <code>wordEnhancer</code> is the last in the composition chain, its <code>text</code> wins.  See this pen:</p>
<p><p data-height="268" data-theme-id="0" data-slug-hash="LNGEww" data-default-tab="result" data-user="npbee" class="codepen">See the Pen <a href="http://codepen.io/npbee/pen/LNGEww/">Prop Name Clash</a> by Nick Ball (<a href="http://codepen.io/npbee">@npbee</a>) on <a href="http://codepen.io">CodePen</a>.</p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>To solve this problem, we can have our higher-order component first accept a function and return <em>another</em> function that then accepts the component to wrap.  This is similar to how the <a href="https://github.com/reactjs/react-redux/blob/master/src/components/connect.js#L34"><code>connect</code></a> works in <code>react-redux</code>.</p>
<pre><code class="lang-javascript"><span class="comment">// textEnhancer.js</span>
export <span class="keyword">default</span> (mergeProps = identity) =&gt; <span class="type">ComposedComponent</span> =&gt; {
    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
        render() {
            const mergedProps = mergeProps({ text: ‘<span class="type">Enhanced</span>!’ }, <span class="keyword">this</span>.props);

            <span class="keyword">return</span> &lt;<span class="type">ComposedComponent</span> {…mergedProps} /&gt;;
        }
    };
}

<span class="comment">// wordEnhancer.js</span>
<span class="comment">// This accepts a `mergeProps` function that </span>
export <span class="keyword">default</span> (mergeProps = identity) =&gt; <span class="type">ComposedComponent</span> =&gt; {
    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedWordComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
        render() {
            const mergedProps = mergeProps({ text: ‘<span class="type">Whoops</span>’ }, <span class="keyword">this</span>.props);

            <span class="keyword">return</span> &lt;<span class="type">ComposedComponent</span> {…mergedProps} /&gt;;
        }
    };
}

<span class="comment">// component.js</span>
<span class="keyword">import</span> textEnhancer from ‘./textEnhancer’;
<span class="keyword">import</span> wordEnhancer from ‘./wordEnhancer’;
<span class="keyword">import</span> compose from ‘lodash/flowRight’;

<span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{  
    render() {
        const { text, word } = <span class="keyword">this</span>.props;

        <span class="comment">// &lt;div&gt;Enhanced! Whoops.&lt;/div&gt;</span>
        <span class="keyword">return</span> &lt;div&gt;{text} {word}&lt;/div&gt;;
    }        
}

export <span class="keyword">default</span> compose(
    textEnhancer(),
    wordEnhancer((props, ownProps) =&gt; ({ …ownProps, word: props.text }))
)(<span class="type">MyComponent</span>);
</code></pre>
<p>In the <code>wordEhancer</code> function, the final props we’re giving to the children are the result of running the <code>mergeProps</code> function with the enhanced props as well as the “own” props provided to the component by its parent.  This allows the consumer of the higher-order components to be in complete control of how its props are named.  It also frees us from having to worry about name-clashes through our app.  Here’s a pen:</p>
<p><p data-height="268" data-theme-id="0" data-slug-hash="aNdOdr" data-default-tab="result" data-user="npbee" class="codepen">See the Pen <a href="http://codepen.io/npbee/pen/aNdOdr/">Merge Props</a> by Nick Ball (<a href="http://codepen.io/npbee">@npbee</a>) on <a href="http://codepen.io">CodePen</a>.</p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<h2 id="level-3-higher-order-higher-order-components">Level 3: Higher-Order, Higher-Order Components</h2>
<p>And now we venture yet one level deeper and experiment with higher-order….higher-order components.  You may noticed that there is some duplication in the above example.  If we were to continue in that fashion, every higher-order component we create would need to adhere to the same signature for accepting a <code>mergeProps</code> function, etc.  </p>
<p>With the introduction of <a href="https://facebook.github.io/react/docs/reusable-components.html#stateless-functions">stateless function components</a>, a whole of world of functional composition has opened up.  We can attempt to reduce the above duplication by introducing a function which accepts a higher-order function and returns a <em>new</em> higher-order function that enhances a component, all built with stateless components.    Example:</p>
<pre><code class="lang-javascript">
<span class="comment">// We define a default merger that just merges both the `props`</span>
<span class="comment">// and `ownProps` together</span>
const defaultMerge = (props, ownProps) =&gt; ({ ...props, ...ownProps });

<span class="comment">// This is a generic `mapper` helper.  It’s a curried function</span>
<span class="comment">// accepting the mapper function, the Component to render, and </span>
<span class="comment">// finally returns a stateless function that just renders</span>
<span class="comment">// the previous component with the mapper function</span>
const mapProps = mapper =&gt; <span class="type">Component</span> =&gt; props =&gt; &lt;<span class="type">Component</span> {...mapper(props)} /&gt;;

<span class="comment">// Our actual higher-order, higher-order function.</span>
<span class="comment">// Also curried, it takes the enhancer function, the merger</span>
<span class="comment">// function, and finally the Component to enhanced and </span>
<span class="comment">// runs the component through a composition chain</span>
const createHigherOrder = enhancer =&gt; (mergeProps = defaultMerge) =&gt; <span class="type">ComposedComponent</span> =&gt; {
  let ownProps;

  <span class="keyword">return</span> compose(

      <span class="comment">// This part is a little messy in that our `mapper` is</span>
      <span class="comment">// really just a way to store the `ownProps` so </span>
      <span class="comment">// we have access to it later</span>
    mapProps(props =&gt; (ownProps = props &amp;&amp; ({ ...props }))),

    <span class="comment">// The next child will be the result of the provided</span>
    <span class="comment">// enhancer function</span>
    enhancer,

    <span class="comment">// Finally, we do one more map.  This time by calling</span>
    <span class="comment">// the provided merger function with the props returned</span>
    <span class="comment">// from the enhancer function _and_ the `ownProps` we</span>
    <span class="comment">// stored earlier.  This will allows the consumer to have </span>
    <span class="comment">// access to all of the props that would have been</span>
    <span class="comment">// passed down to it normally</span>
    mapProps(props =&gt; mergeProps(props, ownProps))
  )(<span class="type">ComposedComponent</span>);

};

<span class="comment">// Notice that we don’t actually have to provide the parent </span>
<span class="comment">// props via `{…this.props}`.</span>
let enhance = <span class="type">ComposedComponent</span> =&gt; {
  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhanced</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
    render() {
      <span class="keyword">return</span> &lt;<span class="type">ComposedComponent</span> text=<span class="symbol">'Text</span> from first enhancer' /&gt;;
    }
  }
}
enhance = createHigherOrder(enhance);

let enhanceAgain = <span class="type">ComposedComponent</span> =&gt; {
  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedAgain</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
    render() {
      <span class="keyword">return</span> &lt;<span class="type">ComposedComponent</span> text=<span class="symbol">'Text</span> from second enhancer' /&gt;; 
    }
  }
}
enhanceAgain = createHigherOrder(enhanceAgain);

<span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
  render() {
    const { text, word, myOwnProp } = <span class="keyword">this</span>.props;

    <span class="keyword">return</span> &lt;div&gt;
      &lt;p&gt;<span class="type">I</span> was provided the &lt;code&gt;text&lt;/code&gt; prop of: &lt;strong&gt;{text}&lt;/strong&gt;&lt;/p&gt;
      &lt;p&gt;<span class="type">I</span> was provided the &lt;code&gt;word&lt;/code&gt; prop of: &lt;strong&gt;{word}&lt;/strong&gt;&lt;/p&gt;
      &lt;p&gt;<span class="type">I</span> was provided the &lt;code&gt;myOwnProp&lt;/code&gt; prop of: &lt;strong&gt;{myOwnProp}&lt;/strong&gt;&lt;/p&gt;
    &lt;/div&gt;;
  }
}

const <span class="type">Enhanced</span> = compose(

    <span class="comment">// Not passing any arguments here so we’ll just use the</span>
    <span class="comment">// default merging function</span>
  enhance(),
  enhanceAgain((props, ownProps) =&gt; ({ ...ownProps, word: props.text }))
)(<span class="type">MyComponent</span>);
</code></pre>
<p>Here’s a working pen:</p>
<p><p data-height="268" data-theme-id="0" data-slug-hash="JXGdNj" data-default-tab="result" data-user="npbee" class="codepen">See the Pen <a href="http://codepen.io/npbee/pen/JXGdNj/">Higher-Order Higher-Order</a> by Nick Ball (<a href="http://codepen.io/npbee">@npbee</a>) on <a href="http://codepen.io">CodePen</a>.</p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p><strong>Note</strong>: The <code>mapProps</code> function is part of the excellent <a href="https://github.com/acdlite/recompose">Recompose</a> library that has all sorts of little helper functions for doing stateless component composition.  </p>
<h2 id="considerations">Considerations</h2>
<p><strong>Total Control</strong></p>
<p>If you noticed above in the last example, the enhancers don’t actually have to pass down their parent props via <code>{…this.props}</code>, they’re simply passing down the props they want their children to have:</p>
<pre><code class="lang-javascript"><span class="class"><span class="keyword">class</span> <span class="title">EnhancedAgain</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
    render() {
      <span class="keyword">return</span> &lt;<span class="type">ComposedComponent</span> text=<span class="symbol">'Text</span> from second enhancer' /&gt;; 
    }
}
</code></pre>
<p>We store the props <em>before</em> running through the enhancer so we can provide those to the enhancer’s children with the given <code>mergeProps</code> function.  This could be seen as a good thing or a bad thing.  On one hand, I’ve never liked passing props via <code>{…this.props}</code>.  When you have long composition chains where all components are passing down every prop, it becomes harder to chase down where a prop originates from.  On the other hand, you can run into the same problem with <code>mergeProps</code> function and there’s also just a bit more “magic” involved.  </p>
<p>Another thing is that you could very easily cut off a supply of props to a component by not including the <code>ownProps</code>:</p>
<pre><code class="lang-javascript"><span class="comment">// The consumer of the enhancer won’t get any of their `ownProps`!</span>
<span class="keyword">const</span> mergeProps = (props, ownProps) =&gt; props;

<span class="comment">// first.js</span>
<span class="keyword">const</span> First = props =&gt; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>{props.text} / {props.myOwnProp}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;
<span class="keyword">export</span> <span class="keyword">default</span> enhance(mergeProps)(First);

<span class="comment">// second.js</span>
<span class="keyword">import</span> First <span class="keyword">from</span> ‘./first’;

<span class="keyword">const</span> Second = props =&gt; <span class="xml"><span class="tag">&lt;<span class="name">First</span> <span class="attr">myOwnProp</span>=<span class="string">‘Hello?’</span> /&gt;</span>;</span>
</code></pre>
<p><strong>Bloated Component Tree</strong></p>
<p>We’re introducing quite a few intermediate components and functions to be able to coordinate the props like this and that’s not totally free.  That said, I haven’t noticed any extreme performance problem using this pattern.  </p>
<p><strong>Mental Overhead</strong></p>
<p>Composing React components like this is not exactly easy to understand at first glance.  Functional programming in general can sometimes be a matter of taste so it bring some overhead that everyone on the team is not necessarily ready to take on.  Personally I think that once it “clicks” then it actually makes everything a lot easier to grok.  It allows me to stop trying to hold everything in my head at once and focus on the function at hand.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Everything said, I’ve been enjoying this pattern at work.  I’ve even gone a bit farther with it and made the <code>createHigherOrder</code> function accept an object that has other options for configuration.  And at the end of the day, testing is the big winner for me with this pattern.  Most parts are just components returning props or functions being called, so it’s quite easy to break each part down into a function that can be tested on its own.</p>
</article>
        </section>
        <div id="disqus_thread"></div>
        <script>
        var disqus_config = function () {
        this.page.url = window.location.href;
        this.page.identifier = window.location.pathname;
        };
        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = '//npbee.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </main>


    <footer>
    <div class="site-logo">
        <a href="/"><img class="icon" src="/static/images/logo.svg" /></a>
    </div>
    <div class="social">
        <a href="http://twitter.com/npbeep" class="main-nav__break-right"><img
            class="icon" src="/static/images/icons/icomoon/twitter.svg" /></a>
        <a href="mailto:nick@npbee.me" class=""><img class="icon" src="/static/images/icons/icomoon/mail.svg" /></a>
        <a href="http://github.com/npbee" class="github-link"><img class="icon" src="/static/images/icons/github/mark.svg" /></a>
    </div>
</footer>


</body>
</html>
